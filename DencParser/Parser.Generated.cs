// This code was generated by the Gardens Point Parser Generator
// Copyright (c) Wayne Kelly, QUT 2005-2010
// (see accompanying GPPGcopyright.rtf)

// GPPG version 1.4.4
// Machine:  THORCELAP2
// DateTime: 2/20/2011 3:46:41 PM
// UserName: thor
// Input file <Parser.gppg - 2/19/2011 9:28:16 AM>

// options: no-lines gplex

using System.Collections.Generic;
using System.Globalization;
using QUT.Gppg;
using Thorsbrain.Denc.Language.Element;
using Thorsbrain.Denc.Language.Element.ClassParts;
using Thorsbrain.Denc.Language.Element.Misc;
using Thorsbrain.Denc.Language.Element.Programs;

namespace Thorsbrain.Denc.Parser
{
    internal enum Token
    {
        error = 1,
        EOF = 2,
        OPENLEVEL = 3,
        CLOSELEVEL = 4,
        ENDOFLINE = 5,
        ENDOFFILE = 6,
        ARCHITECTURE = 7,
        NAMESPACE = 8,
        CLASS = 9,
        SIZE = 10,
        RADIX = 11,
        MASK = 12,
        WORD = 13,
        BYTE = 14,
        SIXBIT = 15,
        ASCIZ = 16,
        ASCII = 17,
        RAD50 = 18,
        POINT = 19,
        XWD = 20,
        IOWD = 21,
        SWITCH = 22,
        CASE = 23,
        PRIVATE = 24,
        ENUM = 25,
        PROTECTED = 26,
        CONSTANT = 27,
        RPAREN = 28,
        FALSE = 29,
        TRUE = 30,
        SEMI = 31,
        EQ = 32,
        NEQ = 33,
        GT = 34,
        GEQ = 35,
        LT = 36,
        LEQ = 37,
        AT = 38,
        COMMA = 39,
        PERIOD = 40,
        COLON = 41,
        IDENTIFIER = 42,
        CONSTANT_DEC = 43,
        CONSTANT_HEX = 44,
        CONSTANT_OCT = 45,
        CONSTANT_FLT = 46,
        CONSTANT_STRING = 47,
        CONSTANT_DECIMAL = 48,
        IF = 49,
        ELSE = 50,
        EQUAL = 51,
        NEW = 52,
        OUT = 53,
        REF = 54,
        OROR = 55,
        ANDAND = 56,
        PLUS = 57,
        MINUS = 58,
        EXCLAM = 59,
        ASTERISK = 60,
        SLASH = 61,
        PERCENT = 62,
        LPAREN = 63
    } ;

    internal partial struct ValueType
    {
        public DencProgram program;
        public Architecture architecture;
        public List<IStatement> statementlist;
        public IStatement statement;
        public List<string> stringlist;
        public ClassHeir classheir;
        public Constant constant;

        public string tVal;

//		public IStatement Statement;
//		public IExpression Expression;
//		public List<IStatement> StatementList;
//		public List<IExpression> ExpressionList;
//		public List<SignatureMember> SignatureMemberList;
//		public SignatureMember SignatureMember;
//		public List<Identifier> IdentifierList;
//		public List<MetaKey> NamedList;
//		public MetaKey MetaKey;
    }

// Abstract base class for GPLEX scanners
    internal abstract class ScanBase : AbstractScanner<ValueType, LexLocation>
    {
        private LexLocation __yylloc = new LexLocation();

        public override LexLocation yylloc
        {
            get { return __yylloc; }
            set { __yylloc = value; }
        }

        protected virtual bool yywrap()
        {
            return true;
        }
    }

    internal partial class Parser : ShiftReduceParser<ValueType, LexLocation>
    {
        // Verbatim content from Parser.gppg - 2/19/2011 9:28:16 AM
/*
 *  Parser for Denc - specifically tuned for GPPG
 *  Process with > GPPG /gplex /no-lines gppg.y
 */
        // End verbatim content from Parser.gppg - 2/19/2011 9:28:16 AM

#pragma warning disable 649
        private static Dictionary<int, string> aliasses;
#pragma warning restore 649
        private static Rule[] rules = new Rule[25];
        private static State[] states = new State[42];

        private static string[] nonTerms = new string[]
                                               {
                                                   "Program", "Architecture", "TopLevelStatementList", "SubLevel",
                                                   "TopLevelStatement",
                                                   "NameSpace", "SubLevelStatement", "Radix", "Word", "Label",
                                                   "SubLevelOption",
                                                   "NameList", "ClassDeclaration", "Constant", "$accept",
                                               };

        static Parser()
        {
            states[0] = new State(new int[] {7, 39}, new int[] {-1, 1, -2, 3});
            states[1] = new State(new int[] {2, 2});
            states[2] = new State(-1);
            states[3] = new State(new int[] {8, 7, 9, 14, 5, 37}, new int[] {-3, 4, -5, 38, -6, 6, -13, 13});
            states[4] = new State(new int[] {8, 7, 9, 14, 5, 37, 2, -2}, new int[] {-5, 5, -6, 6, -13, 13});
            states[5] = new State(-5);
            states[6] = new State(-6);
            states[7] = new State(new int[] {42, 12}, new int[] {-12, 8});
            states[8] = new State(new int[] {5, 9, 40, 10});
            states[9] = new State(-9);
            states[10] = new State(new int[] {42, 11});
            states[11] = new State(-11);
            states[12] = new State(-10);
            states[13] = new State(-7);
            states[14] = new State(new int[] {42, 15});
            states[15] = new State(new int[] {5, 16});
            states[16] = new State(new int[] {3, 17});
            states[17] = new State(new int[] {9, 14, 11, 24, 13, 29, 42, 33, 5, 35},
                                   new int[] {-4, 18, -7, 36, -13, 21, -11, 22, -8, 23, -9, 28, -10, 32});
            states[18] = new State(new int[] {4, 19, 9, 14, 11, 24, 13, 29, 42, 33, 5, 35},
                                   new int[] {-7, 20, -13, 21, -11, 22, -8, 23, -9, 28, -10, 32});
            states[19] = new State(-12);
            states[20] = new State(-14);
            states[21] = new State(-15);
            states[22] = new State(-16);
            states[23] = new State(-19);
            states[24] = new State(new int[] {27, 27}, new int[] {-14, 25});
            states[25] = new State(new int[] {5, 26});
            states[26] = new State(-21);
            states[27] = new State(-23);
            states[28] = new State(-20);
            states[29] = new State(new int[] {27, 27}, new int[] {-14, 30});
            states[30] = new State(new int[] {5, 31});
            states[31] = new State(-22);
            states[32] = new State(-17);
            states[33] = new State(new int[] {41, 34});
            states[34] = new State(-24);
            states[35] = new State(-18);
            states[36] = new State(-13);
            states[37] = new State(-8);
            states[38] = new State(-4);
            states[39] = new State(new int[] {42, 40});
            states[40] = new State(new int[] {5, 41});
            states[41] = new State(-3);

            for (var sNo = 0; sNo < states.Length; sNo++) states[sNo].number = sNo;

            rules[1] = new Rule(-15, new int[] {-1, 2});
            rules[2] = new Rule(-1, new int[] {-2, -3});
            rules[3] = new Rule(-2, new int[] {7, 42, 5});
            rules[4] = new Rule(-3, new int[] {-5});
            rules[5] = new Rule(-3, new int[] {-3, -5});
            rules[6] = new Rule(-5, new int[] {-6});
            rules[7] = new Rule(-5, new int[] {-13});
            rules[8] = new Rule(-5, new int[] {5});
            rules[9] = new Rule(-6, new int[] {8, -12, 5});
            rules[10] = new Rule(-12, new int[] {42});
            rules[11] = new Rule(-12, new int[] {-12, 40, 42});
            rules[12] = new Rule(-13, new int[] {9, 42, 5, 3, -4, 4});
            rules[13] = new Rule(-4, new int[] {-7});
            rules[14] = new Rule(-4, new int[] {-4, -7});
            rules[15] = new Rule(-7, new int[] {-13});
            rules[16] = new Rule(-7, new int[] {-11});
            rules[17] = new Rule(-7, new int[] {-10});
            rules[18] = new Rule(-7, new int[] {5});
            rules[19] = new Rule(-11, new int[] {-8});
            rules[20] = new Rule(-11, new int[] {-9});
            rules[21] = new Rule(-8, new int[] {11, -14, 5});
            rules[22] = new Rule(-9, new int[] {13, -14, 5});
            rules[23] = new Rule(-14, new int[] {27});
            rules[24] = new Rule(-10, new int[] {42, 41});
        }

        protected override void Initialize()
        {
            InitSpecialTokens((int) Token.error, (int) Token.EOF);
            InitStates(states);
            InitRules(rules);
            InitNonTerminals(nonTerms);
        }

        protected override void DoAction(int action)
        {
            switch (action)
            {
                case 2: // Program -> Architecture, TopLevelStatementList
                    {
                        CurrentSemanticValue.program =
                            DencMainProgram =
                            new DencProgram(ValueStack[ValueStack.Depth - 2].architecture,
                                            ValueStack[ValueStack.Depth - 1].statementlist);
                    }
                    break;
                case 3: // Architecture -> ARCHITECTURE, IDENTIFIER, ENDOFLINE
                    {
                        CurrentSemanticValue.architecture = new Architecture(ValueStack[ValueStack.Depth - 2].tVal);
                    }
                    break;
                case 4: // TopLevelStatementList -> TopLevelStatement
                    {
                        CurrentSemanticValue.statementlist = new List<IStatement>
                                                                 {ValueStack[ValueStack.Depth - 1].statement};
                    }
                    break;
                case 5: // TopLevelStatementList -> TopLevelStatementList, TopLevelStatement
                    {
                        ValueStack[ValueStack.Depth - 2].statementlist.Add(ValueStack[ValueStack.Depth - 1].statement);
                        CurrentSemanticValue.statementlist = ValueStack[ValueStack.Depth - 2].statementlist;
                    }
                    break;
                case 6: // TopLevelStatement -> NameSpace
                    {
                        CurrentSemanticValue.statement = ValueStack[ValueStack.Depth - 1].statement;
                    }
                    break;
                case 7: // TopLevelStatement -> ClassDeclaration
                    {
                        CurrentSemanticValue.statement = ValueStack[ValueStack.Depth - 1].classheir;
                    }
                    break;
                case 8: // TopLevelStatement -> ENDOFLINE
                    {
                        CurrentSemanticValue.statement = null;
                    }
                    break;
                case 9: // NameSpace -> NAMESPACE, NameList, ENDOFLINE
                    {
                        CurrentSemanticValue.statement = new NameSpace(ValueStack[ValueStack.Depth - 2].stringlist);
                    }
                    break;
                case 10: // NameList -> IDENTIFIER
                    {
                        CurrentSemanticValue.stringlist = new List<string> {ValueStack[ValueStack.Depth - 1].tVal};
                    }
                    break;
                case 11: // NameList -> NameList, PERIOD, IDENTIFIER
                    {
                        ValueStack[ValueStack.Depth - 3].stringlist.Add(ValueStack[ValueStack.Depth - 1].tVal);
                        CurrentSemanticValue.stringlist = ValueStack[ValueStack.Depth - 3].stringlist;
                    }
                    break;
                case 12: // ClassDeclaration -> CLASS, IDENTIFIER, ENDOFLINE, OPENLEVEL, SubLevel, 
                    //                     CLOSELEVEL
                    {
                        CurrentSemanticValue.classheir = new ClassHeir(ValueStack[ValueStack.Depth - 5].tVal,
                                                                       ValueStack[ValueStack.Depth - 2].statementlist);
                    }
                    break;
                case 13: // SubLevel -> SubLevelStatement
                    {
                        CurrentSemanticValue.statementlist = new List<IStatement>
                                                                 {ValueStack[ValueStack.Depth - 1].statement};
                    }
                    break;
                case 14: // SubLevel -> SubLevel, SubLevelStatement
                    {
                        ValueStack[ValueStack.Depth - 2].statementlist.Add(ValueStack[ValueStack.Depth - 1].statement);
                        CurrentSemanticValue.statementlist = ValueStack[ValueStack.Depth - 2].statementlist;
                    }
                    break;
                case 15: // SubLevelStatement -> ClassDeclaration
                    {
                        CurrentSemanticValue.statement = ValueStack[ValueStack.Depth - 1].classheir;
                    }
                    break;
                case 16: // SubLevelStatement -> SubLevelOption
                    {
                        CurrentSemanticValue.statement = ValueStack[ValueStack.Depth - 1].statement;
                    }
                    break;
                case 17: // SubLevelStatement -> Label
                    {
                        CurrentSemanticValue.statement = ValueStack[ValueStack.Depth - 1].statement;
                    }
                    break;
                case 18: // SubLevelStatement -> ENDOFLINE
                    {
                        CurrentSemanticValue.statement = null;
                    }
                    break;
                case 19: // SubLevelOption -> Radix
                    {
                        CurrentSemanticValue.statement = ValueStack[ValueStack.Depth - 1].statement;
                    }
                    break;
                case 21: // Radix -> RADIX, Constant, ENDOFLINE
                    {
                        CurrentSemanticValue.statement = new SetRadix(ValueStack[ValueStack.Depth - 2].constant);
                    }
                    break;
                case 22: // Word -> WORD, Constant, ENDOFLINE
                    {
                        CurrentSemanticValue.statement = new Word(ValueStack[ValueStack.Depth - 2].constant);
                    }
                    break;
                case 23: // Constant -> CONSTANT
                    {
                        CurrentSemanticValue.constant = new Constant(ValueStack[ValueStack.Depth - 1].tVal);
                    }
                    break;
                case 24: // Label -> IDENTIFIER, COLON
                    {
                        CurrentSemanticValue.statement = new Label(ValueStack[ValueStack.Depth - 2].tVal);
                    }
                    break;
            }
        }

        protected override string TerminalToString(int terminal)
        {
            if (aliasses != null && aliasses.ContainsKey(terminal))
                return aliasses[terminal];
            else if (((Token) terminal).ToString() != terminal.ToString(CultureInfo.InvariantCulture))
                return ((Token) terminal).ToString();
            else
                return CharToString((char) terminal);
        }
    }
}